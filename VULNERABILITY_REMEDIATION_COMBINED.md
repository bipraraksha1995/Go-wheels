# Vulnerability Remediation (Combined)

This file consolidates the remediation guidance and secure-coding examples.

See the primary guide: `VULNERABILITY_REMEDIATION.md` and the supplement:

- `VULNERABILITY_REMEDIATION_APPEND.md`

---

## Secure Coding Remediations (Examples)

The following examples show incorrect (vulnerable) code and secure replacements you should prefer.

1. SQL Injection ‚Äî Solution

‚ùå Wrong (never do)

```python
query = f"SELECT * FROM users WHERE username='{username}'"
```

‚úÖ Correct (use parameterized queries / ORM)

Django ORM

```python
User.objects.get(username=username)
```

Raw SQL

```python
cursor.execute(
    "SELECT * FROM users WHERE username=%s",
    [username]
)
```

üëâ Database driver automatically escapes input and prevents injection.

2. Command Injection ‚Äî Solution

‚ùå Wrong

```python
os.system("ping " + user_ip)
```

‚úÖ Correct

```python
import subprocess
subprocess.run(["ping", user_ip])
```

No shell invocation: arguments are passed as a list which prevents injection.

3. Unsafe Deserialization ‚Äî Solution

‚ùå Wrong

```python
pickle.loads(user_data)
eval(user_input)
yaml.load(data)
```

‚úÖ Correct

Use JSON only:

```python
import json
json.loads(user_data)
```

4. Missing Parameter Validation ‚Äî Solution

Use strict validation rules.

Example: Age

```python
if not age.isdigit() or int(age) < 0 or int(age) > 120:
    raise ValueError("Invalid age")
```

Example: Email

```python
from django.core.validators import validate_email
validate_email(email)
```

5. Use Django Forms / DRF Serializers (Best Practice)

They auto-handle validation and coercion.

Django Form

```python
from django import forms

class UserForm(forms.Form):
    age = forms.IntegerField(min_value=1, max_value=120)
```

DRF Serializer

```python
from rest_framework import serializers

class UserSerializer(serializers.Serializer):
    email = serializers.EmailField()
    age = serializers.IntegerField(min_value=1, max_value=120)
```

---

Include these patterns in code reviews and add linters/static checks where possible (Bandit, semgrep rules, or custom scripts) to catch regressions.
